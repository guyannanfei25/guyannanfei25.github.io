---
layout: post
title: 一次栈溢出引发的思考
categories: [经验]
description: 栈溢出
keywords: 栈溢出, 思考
---

许久没有写C/C++程序，有些生疏，最近验证一项功能，写了一个C++程序，
第一天还好好的，第二天就各种coredump，连最简单的输出到标准输出语句
都无法正常执行，耗费了组里两个大牛工程师找了一下午，隐藏的太深。
不禁感叹，对于这种系统编程语言，基本功还是太重要了。不出问题感觉大家
水平都差不多，只有在问题面前才是显示水平的时候。对于服务端开发人员，
操作系统的知识还是太重要了，一定要打好基础，将所有知识融会贯通，不要
太急于求成。

## 缘由
一个验证的测试程序，为了方便，直接将大部分别人之前写的代码复制过来，只
稍微改了下业务逻辑，第一天程序还能征程运行，第二天各种coredump，起初以为是因为别人改了基础环境库，找了半天发现不是这个原因，gdb也各种无法跟
踪。

## 原因
最后才发现是直接复制别人的程序，别人之前定义一个很大的buf变量，分布在栈
空间上；第一天能正常运行，第二天却不能，估计是因为别人更改了系统环境变量
将一个程序最大栈空间设小了，该参数可以通过：`ulimit -s`来查看。查看发现
程序分配的buf大小远大于系统设置的每个程序栈的大小。
大家都知道程序在内存中的分布情况：栈是向下增长，估计太大，破坏了内存中其
他部分地址空间的内容，导致打印到标准输出这么简单的语句都会出现coredump。

## 经验
栈分配不能太大，需要太大可变的空间可以使用堆内存。

## 示例
分配到堆内存可以使用shared_ptr来管理内存，以防内存泄露。
